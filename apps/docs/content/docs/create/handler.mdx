---
title: Handler functions
---

SafeFn has two types of handler functions, `handler()` and `safeHandler()`. These both take in an object with the following properties:

- `args.input`: The result of parsing the input schema.
- `args.unsafeRawInput`: The unparsed input of your function.
- `args.ctx`: The `Ok` return value of the parent handler function or undefined if no parent handler function is set.
- `args.ctxInput`: An array of all the parsed input of the parent handler functions. This could be handy in a pinch, altho ideally you'd just use the `ctx` property to pass the actual data you want.

### Handler

`handler()` takes in a function that will be called when your SafeFn is executed. This function should return a `Result<TData,TError>` or `Promise<Result<TData,TError>>`.
If you set an output schema, the `TData` type is constrained to the parsed output type of your schema. Otherwise, you can return any `Result` type.

The returned types from `run()` and `createAction()()` are updated with the inferred return type of your handler function.

```ts
const mySafeFunction = SafeFn.new()
  .unparsedInput<{ firstName: string; lastName: string }>()
  .output(z.object({ fullName: z.string() }))
  .handler((args) => {
    // Error: Type Ok<{ name: string; }> is not assignable to type Ok<{ fullName: string; }> // [!code highlight]
    return ok({
      fullName: `${args.unsafeRawInput.firstName} ${args.unsafeRawInput.lastName}`,
    });
  });
```

### Safe Handler

Instead of using `handler()`, you can also use `safeHandler()`. This offers the same functionality as NeverThrow's `safeTry()` and requires an async generator function.
This is probably the route you want to take if the rest of your codebase is built with NeverThrow, as it allows ergonomic "return if error" handling.

Consider the following example:

```ts
// Fake function declarations
declare function getUserTodoList(): ResultAsync<string[], { code: "DB_ERROR" }>;
declare function getTodoById(
  id: string,
): ResultAsync<
  { id: string; title: string; description: string },
  { code: "DB_ERROR" }
>;

const getLastUserTodoTitle = SafeFn.new().handler(async () => {
  const todoList = await getUserTodoList();
  if (todoList.isErr()) {
    return todoList;
  }
  if (!todoList.value.length) {
    return err({
      code: "NO_TODOS",
    });
  }
  const lastTodoId = todoList.value[todoList.value.length - 1];
  const todo = await getTodoById(lastTodoId);
  if (todo.isErr()) {
    return todo;
  }
  return ok(todo.value.title);
});
```

This can be rewritten using `safeHandler()` as follows:

```ts
// Fake function declarations
declare function getUserTodoList(): ResultAsync<string[], { code: "DB_ERROR" }>;
declare function getTodoById(
  id: string,
): ResultAsync<
  { id: string; title: string; description: string },
  { code: "DB_ERROR" }
>;

const getLastUserTodoTitle = SafeFn.new().handler(async function* () {
  const todoList = yield* getUserTodoList().safeUnwrap();
  if (!todoList.length) {
    return err({
      code: "NO_TODOS",
    });
  }
  const lastTodoId = todoList[todoList.length - 1];
  const todo = yield* getTodoById(lastTodoId).safeUnwrap();
  return ok(todo.title);
});
```

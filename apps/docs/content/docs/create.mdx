---
title: Creating a SafeFn
description: Components
---

## Instantiating

{/* TODO: chaining page */}
You can create a SafeFn by using the `.new()` method. Here you can optionally pass in a parent handler (see chaining)

```ts
import { parentFunction } from "./some-file";

const myySafeFunction = SafeFn.new();
const mySafeFunction2 = SafeFn.new(parentFunction);
```

## Input and output

### Input schema

You can set an input schema for your SafeFn by using `input()`. This takes in a Zod schema and will type the arguments for your handler function as well as the required input to execute the SafeFn.

```ts
const mySafeFunction = SafeFn.new()
  .input(z.object({ firstName: z.string(), lastName: z.string() }))
  .handler((args) => {
    /*        ^ ?
      { parsedInput: { firstName: string; lastName: string };
        unparsedInput: { firstName: string; lastName: string }};
        ...
     */
    return ok({
      fullName: `${args.parsedInput.firstName} ${args.parsedInput.lastName}`,
    });
  });
```

When parsing is not succesful, your handler function is not called and the error is returned. As such, the following types are added to the returntype of the function:

- when using `run()`

```ts
ResultAsync<{
  never,
  {
    code: "INPUT_PARSING";
    cause: z.ZodError<{
      firstName: string;
    lastName: string;
  }>;
  }
}>;
```

- when using `createAction()()` (full errors are stripped here as classes can not be sent via a Server Action and stack traces should not be shipped to the client)

```ts
ActionResul<
  never,
  {
    code: "INPUT_PARSING";
    cause: {
      formattedError: z.ZodFormattedError<{
        firstName: string;
        lastName: string;
      }>;
      flattenedError: z.typeToFlattenedError<
        {
          firstName: string;
          lastName: string;
        },
        string
      >;
    };
  }
>;
```

{/* TODO: link error handling. Also look into how this is actually handled again lol */}

<Callout type="warn">
  Other than the expected parse errors, Zod can also throw when using features
  like `coerce` or passing functions to `transform()`. These will be caught and
  passed to your error handler.
</Callout>

### Unparsed input

Unparsed input is the type of the input that is needed to execute your SafeFn and is passed as an argument to your handler function. When using an input schema, this type is inferred.
If you're not doing that you can manually set it by passing it as a generic to `unparsedInput<T>()`;

<Callout type="warn">
  While this adds type safety, it's highly recommended to use an input schema if
  your function will be exposed as a Server Action or regular API endpoint as
  types aren't checked at runtime.
</Callout>

```ts
const mySafeFunction = SafeFn.new()
  .unparsedInput<{ firstName: string; lastName: string }>()
  .output(z.object({ fullName: z.string() }))
  .handler((args) => {
    /*        ^ ?
      { parsedInput: undefined;
        unparsedInput: { firstName: string; lastName: string }};
        ...
     */
    return ok({
      fullName: `${args.unparsedInput.firstName} ${args.unparsedInput.lastName}`,
    });
  });
```

### Output schema

You can set an output schema for your SafeFn by using `output()`. This takes in a Zod schema and will type the return type of your handler function as well as the output of the SafeFn.

```ts
const mySafeFunction = SafeFn.new()
  .input(z.object({ firstName: z.string(), lastName: z.string() }))
  .output(z.object({ fullName: z.string() }))
  .handler((args) => {
    return ok({
      fullName: `${args.parsedInput.firstName} ${args.parsedInput.lastName}`,
    });
  });
```

<Callout type="info">
  When your handler returns an `Err`, output parsing is skipped. If your handler
  can only return an `Err` result, the possible error types from the output
  schema are omitted from the return type.
</Callout>

When output parsing is not succesful, an `Err` is returned. The following types are added to the return type:

- when using `run()`

```ts
ResultAsync<{
  never,
  {
    code: "OUTPUT_PARSING";
    cause: z.ZodError<{ fullName: string }>;
  };
}>;
```

- when using `createAction()()` (full errors are stripped here as classes can not be sent via a Server Action and stack traces should not be shipped to the client)

```ts
ActionResult<
  never,
  {
    code: "OUTPUT_PARSING";
    cause: {
      formattedError: z.ZodFormattedError<{ fullName: string }>;
      flattenedError: z.typeToFlattenedError<{ fullName: string }, string>;
    };
  }
>;
```

{/* TODO: link error handling. Also look into how this is actually handled again lol */}

<Callout type="warn">
  Other than the expected parse errors, Zod can also throw when using features
  like `coerce` or passing functions to `transform()`. These will be caught and
  passed to your error handler.
</Callout>

## Handler functions

### Handler

`handler()` takes in a function that will be called when your SafeFn is executed. This function should return a `Result<TData,TError>` or `Promise<Result<TData,TError>>`.
If you set an output schema, the `TData` type is constrained to the parsed output type of your schema. Otherwise, you can return any `Result` type.

The returned types from `run()` and `createAction()()` are updated with the inferred return type of your handler function.

```ts
const mySafeFunction = SafeFn.new()
  .unparsedInput<{ firstName: string; lastName: string }>()
  .output(z.object({ fullName: z.string() }))
  .handler((args) => {
    // Error: Type Ok<{ name: string; }> is not assignable to type Ok<{ fullName: string; }> // [!code highlight]
    return ok({
      fullName: `${args.unparsedInput.firstName} ${args.unparsedInput.lastName}`,
    });
  });
```

the following arguments are passed to the handler function:

- `args.parsedInput`: The result of parsing the input schema.
- `args.unparsedInput`: The unparsed input of your function.
- `args.ctx`: The `Ok` return value of the parent handler function or undefined if no parent handler function is set.

### Safe Handler

Instead of using `handler()`, you can also use `safeHandler()`. This offers the same functionality as NeverThrow's `safeTry()` and requires an async generation function.
This is probably the route you want to take if the rest of your codebase is built with NeverThrow, as it allows ergonomic "return if error" handling.

Consider the following example:

```ts
// Fake function declarations
declare function getUserTodoList(): ResultAsync<string[], { code: "DB_ERROR" }>;
declare function getTodoById(
  id: string,
): ResultAsync<
  { id: string; title: string; description: string },
  { code: "DB_ERROR" }
>;

const getLastUserTodoTitle = SafeFn.new().handler(async () => {
  const todoList = await getUserTodoList();
  if (todoList.isErr()) {
    return todoList;
  }
  if (!todoList.value.length) {
    return err({
      code: "NO_TODOS",
    });
  }
  const lastTodoId = todoList.value[todoList.value.length - 1];
  const todo = await getTodoById(lastTodoId);
  if (todo.isErr()) {
    return todo;
  }
  return ok(todo.value.title);
});
```

This can be rewritten using `safeHandler()` as follows:

```ts
// Fake function declarations
declare function getUserTodoList(): ResultAsync<string[], { code: "DB_ERROR" }>;
declare function getTodoById(
  id: string,
): ResultAsync<
  { id: string; title: string; description: string },
  { code: "DB_ERROR" }
>;

const getLastUserTodoTitle2 = SafeFn.new().handler(async function* () {
  const todoList = yield* (await getUserTodoList()).safeUnwrap();
  if (!todoList.length) {
    return err({
      code: "NO_TODOS",
    });
  }
  const lastTodoId = todoList[todoList.length - 1];
  const todo = yield* (await getTodoById(lastTodoId)).safeUnwrap();
  return ok(todo.title);
});
```

## Cards

<Cards>
  <Card title="Learn more about Next.js" href="https://nextjs.org/docs" />
  <Card title="Learn more about Fumadocs" href="https://fumadocs.vercel.app" />
</Cards>
